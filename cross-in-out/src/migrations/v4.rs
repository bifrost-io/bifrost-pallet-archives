// This file is part of Bifrost.

// Copyright (C) Liebi Technologies PTE. LTD.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

use crate::*;
use frame_support::traits::OnRuntimeUpgrade;
#[cfg(feature = "try-runtime")]
use sp_runtime::TryRuntimeError;

const LOG_TARGET: &str = "cross-in-out::migration";

pub struct MigrateToV4<T>(sp_std::marker::PhantomData<T>);
impl<T: Config> OnRuntimeUpgrade for MigrateToV4<T> {
	fn on_runtime_upgrade() -> frame_support::weights::Weight {
		// Check the storage version
		let in_code_version = Pallet::<T>::in_code_storage_version();
		let on_chain_version = Pallet::<T>::on_chain_storage_version();
		// Transform storage values
		// We transform the storage values from the old into the new format.
		if on_chain_version == 3 && in_code_version == 4 {
			let mut count = 0;

			// Transform storage values
			// We transform the storage values from the old into the new format.
			log::info!(target: LOG_TARGET, "Migrating AccountToOuterMultilocation v2::MultiLocation ➜ v3::MultiLocation");
			for (currency_id, account_id, v2_location) in AccountToOuterMultilocation::<T>::drain()
			{
				let v3_location: MultiLocation = v2_location;
				AccountToOuterMultilocation::<T>::insert(currency_id, account_id, v3_location);
				count += 1;
			}

			log::info!(target: LOG_TARGET, "Migrating OuterMultilocationToAccount v2::MultiLocation ➜ v3::MultiLocation");
			for (currency_id, old_key, account) in OuterMultilocationToAccount::<T>::drain() {
				let v3_key: MultiLocation = old_key;
				OuterMultilocationToAccount::<T>::insert(currency_id, v3_key, account);
				count += 1;
			}

			// Update the storage version
			in_code_version.put::<Pallet<T>>();

			// Return the consumed weight
			T::DbWeight::get().reads_writes(count as u64 + 1, count as u64 + 1)
		} else {
			// We don't do anything here.
			Weight::zero()
		}
	}

	#[cfg(feature = "try-runtime")]
	fn pre_upgrade() -> Result<alloc::vec::Vec<u8>, TryRuntimeError> {
		let account_to_outer_multilocation = AccountToOuterMultilocation::<T>::iter().count();
		let outer_multilocation_to_account = OuterMultilocationToAccount::<T>::iter().count();
		log::info!(target: LOG_TARGET, "AccountToOuterMultilocation pre-migrate storage count: {:?}", account_to_outer_multilocation);
		log::info!(target: LOG_TARGET, "OuterMultilocationToAccount pre-migrate storage count: {:?}", outer_multilocation_to_account);

		let combined_data = (
			account_to_outer_multilocation as u64,
			outer_multilocation_to_account as u64,
		);
		Ok(combined_data.encode())
	}

	#[cfg(feature = "try-runtime")]
	fn post_upgrade(cnt: alloc::vec::Vec<u8>) -> Result<(), TryRuntimeError> {
		let (old_account_to_outer_multilocation, old_outer_multilocation_to_account): (u64, u64) =
			Decode::decode(&mut cnt.as_slice()).expect(
				"the state parameter should be something that was generated by pre_upgrade",
			);

		let new_account_to_outer_multilocation = AccountToOuterMultilocation::<T>::iter().count();
		log::info!(
			target: LOG_TARGET,
			"AccountToOuterMultilocation post-migrate storage count: {:?}",
			new_account_to_outer_multilocation
		);

		let new_outer_multilocation_to_account = OuterMultilocationToAccount::<T>::iter().count();
		log::info!(
			target: LOG_TARGET,
			"OuterMultilocationToAccount post-migrate storage count: {:?}",
			new_outer_multilocation_to_account
		);

		ensure!(
			new_account_to_outer_multilocation as u64 == old_account_to_outer_multilocation,
			"Post-migration AccountToOuterMultilocation count does not match pre-migration count"
		);
		ensure!(
			new_outer_multilocation_to_account as u64 == old_outer_multilocation_to_account,
			"Post-migration OuterMultilocationToAccount count does not match pre-migration count"
		);

		Ok(())
	}
}
